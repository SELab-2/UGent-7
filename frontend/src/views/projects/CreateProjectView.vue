<script setup lang="ts">
import Calendar from 'primevue/calendar';
import BaseLayout from '@/components/layout/base/BaseLayout.vue';
import FileUpload from 'primevue/fileupload';
import Title from '@/components/layout/Title.vue';
import ErrorMessage from '@/components/forms/ErrorMessage.vue';
import InputText from 'primevue/inputtext';
import Editor from '@/components/forms/Editor.vue';
import Button from 'primevue/button';
import Dropdown from 'primevue/dropdown';
import InputNumber from 'primevue/inputnumber';
import InputSwitch from 'primevue/inputswitch';
import Tree from 'primevue/tree';
import { reactive, computed, ref } from 'vue';
import { useRouter, useRoute } from 'vue-router';
import { useI18n } from 'vue-i18n';
import { Project } from '@/types/Project';
import { useProject } from '@/composables/services/project.service';
import { useStructureCheck } from '@/composables/services/structure_check.service';
import { required, helpers } from '@vuelidate/validators';
import { useVuelidate } from '@vuelidate/core';
import { useCourses } from '@/composables/services/course.service';

/* Composable injections */
const { t } = useI18n();
const { push } = useRouter();
const { params } = useRoute();

/* Service injection */
const { createProject } = useProject();
const { course, getCourseByID } = useCourses();
const { structureChecks, getStructureCheckByProject} = useStructureCheck();


/* Form content */
const form = reactive({
    name: '',
    description: '',
    startDate: new Date(),
    deadline: new Date(),
    groupSize: 1,
    maxScore: 10,
    visibility: true,
    scoreVisibility: false,
    dockerScript: null,
    submissionStructure: null,
});

// Define validation rules for each form field
const rules = computed(() => {
    return {
        name: { required: helpers.withMessage(t('validations.required'), required) },
        startDate: { required: helpers.withMessage(t('validations.required'), required) },
        deadline: {
            required: helpers.withMessage(t('validations.required'), required),
            minDate: helpers.withMessage(t('validations.deadline'), (value: Date) => value > form.startDate),
        },
        groupSize: { required: helpers.withMessage(t('validations.required'), required) },
        maxScore: { required: helpers.withMessage(t('validations.required'), required) },
    };
});

// Function to handle the file upload of a docker script
const onDockerScriptUpload = (event: any): void => {
    form.dockerScript = event.files[0];
};

// Function to handle the file upload of a zip file containing the submission structure
const onZipStructureUpload = (event: any): void => {
    form.submissionStructure = event.files[0];
};

// useVuelidate function to perform form validation
const v$ = useVuelidate(rules, form);

/**
 * Function to submit the project form.
 */
async function submitProject(): Promise<void> {
    // Validate the form
    const validated = await v$.value.$validate();

    // Get the course object from the course ID
    await getCourseByID(params.courseId as string);

    // Only submit the form if the validation was successful
    if (validated && course.value !== null) {
        // Pass the project data to the service
        await createProject(
            new Project(
                '', // ID not needed for creation, will be generated by the backend
                form.name,
                form.description,
                form.visibility,
                false, // Default not archived
                false, // Default the groups are not locked
                form.startDate,
                form.deadline,
                form.maxScore,
                form.scoreVisibility,
                form.groupSize,
                course.value,
                form.submissionStructure,
            ),
            params.courseId as string,
        );

        // Redirect to the dashboard overview
        await push({ name: 'dashboard' });
    }
}

interface TreeNode_struct {
        label: string;
        children?: TreeNode_struct[];
        key: string;
        sort: string
    }

// Define a method to compute the style for each node
function getNodeStyle(node: TreeNode_struct) {
    console.log('getNodeStyle called'); // Add logging to check if the function is called
    // Check if the node meets a certain condition, e.g., has a specific label
    if (node.sort === 'file') return {color: 'black'};
    if (node.sort === 'obligated') return {color: 'green'};
    if (node.sort === 'blocked') return {color: 'red'};
    // If no condition is met, return an empty object
    return {};
}

// Define tree data as ref
const nodes = ref<TreeNode_struct[]>([
    {
        key: '1',
        label: t('structure_checks.empty'),
        sort:'empty'
    }
]);

// Function to load structure checks into nodes
async function loadStructureChecks() {
    console.log("get structure checks pressed")
    await getStructureCheckByProject("1235") //3001
    console.log(structureChecks.value)

    // Initialize an empty array for the result
    let result: TreeNode_struct[] = [];

    // Initialize a level object with the result array
    let level = { result };

    // Iterate over each path
    (structureChecks.value||[]).forEach(structureCheck => {
        let path = structureCheck.name;
        let obligated = structureCheck.obligated_extensions;
        let blocked = structureCheck.blocked_extensions;
        // console.log(obligated);
        // console.log(blocked);
        // Split the path into individual parts
        path.split('/').reduce((r: any, name: string, i: number, a: string[]) => {
            // Check if the current part doesn't exist in the hierarchy
            if (!r[name]) {
                // Create a new node for the current part
                r[name] = { result: [] };
                // Add the node to the result array
                r.result.push(
                    {
                        key: `${path}_{name}_${i}`,
                        label: name,
                        children: r[name].result,
                        sort: 'file'
                    }
                );
                
                if (i === a.length - 1) {
                    if(obligated){
                        // If it's the deepest path and there are obligated extensions, add them as children
                        obligated.forEach((ext: any, index: number) => {
                            r[name].result.push({
                                key: `${path}_${name}_obligated_${index}`,
                                label: ext.extension,
                                sort: 'obligated'
                            });
                        });
                    }
                    if(blocked){
                        // If it's the deepest path and there are blocked extensions, add them as children
                        blocked.forEach((ext: any, index: number) => {
                            r[name].result.push({
                                key: `${path}_${name}_blocked_${index}`,
                                label: ext.extension,
                                sort: 'blocked'
                            });
                        });
                    }
                }
            }
            // Return the current node
            return r[name];
        }, level);
    });

    // Assign the fetched data to the nodes
    nodes.value = result[0].children;
}

const editedNode = ref(null);
const editedNodeName = ref('');
const nodeTypes = [
    { label: 'File', value: 'file' },
    { label: 'Obligated', value: 'obligated' },
    { label: 'Blocked', value: 'blocked' }
];
const editedNodeType = ref(nodeTypes[0].value);

const onNodeSelect = (event) => {
    editedNode.value = event;
    console.log(editedNode.value)
};

const editSelectedNode = () => {
    if (editedNode.value.sort != "empty"){
        editedNode.value.label = editedNodeName.value;
    }
    console.log(editedNode.value); // Log the selected TreeNode
};

let counter = 0;
const addSelectedNode = () => {
    if (editedNode.value.sort != "empty"){
        counter += 1;
        let node = {
            key: `${editedNode.value.label}_${counter}_obligated_${editedNodeName.value}`,
            label: editedNodeName.value,
            sort: editedNodeType.value.value,
            children: []
        }
        editedNode.value.children.push(node);
        editedNode.value.children.sort((a: any, b: any) => {
            const order = { 'obligated': 0, 'blocked': 1, 'file': 2 };
            return order[a.sort] - order[b.sort];
        });
    }
    console.log(editedNode.value); // Log the selected TreeNode
};

// function addNode(path: string, extension: string, blocked_ext: boolean){
//     // Initialize an empty array for the result
//     let result: TreeNode_struct[] = nodes.value;

//     // Initialize a level object with the result array
//     let level = { result };

     
//     let obligated = [extension];
//     let blocked = [extension];
//     if(blocked_ext){
//         obligated = [];
//     }else{
//         blocked = [];
//     }
//     console.log(obligated)
//     console.log(blocked)
//     console.log(path)
//     // console.log(obligated);
//     // console.log(blocked);
//     // Split the path into individual parts
//     path.split('/').reduce((r: any, name: string, i: number, a: string[]) => {
//         // Check if the current part doesn't exist in the hierarchy
//         if (!r[name]) {
//             // Create a new node for the current part
//             r[name] = { result: [] };
//             // Add the node to the result array
//             r.result.push(
//                 {
//                     key: `${path}_{name}_${i}`,
//                     label: name,
//                     children: r[name].result,
//                     sort: 'file'
//                 }
//             );
            
//             if (i === a.length - 1) {
//                 if(obligated){
//                     // If it's the deepest path and there are obligated extensions, add them as children
//                     obligated.forEach((ext: any, index: number) => {
//                         r[name].result.push({
//                             key: `${path}_${name}_obligated_${index}`,
//                             label: ext,
//                             sort: 'obligated'
//                         });
//                     });
//                 }
//                 if(blocked){
//                     // If it's the deepest path and there are blocked extensions, add them as children
//                     blocked.forEach((ext: any, index: number) => {
//                         r[name].result.push({
//                             key: `${path}_${name}_blocked_${index}`,
//                             label: ext,
//                             sort: 'blocked'
//                         });
//                     });
//                 }
//             }
//         }
//         // Return the current node
//         return r[name];
//     }, level);

//     console.log(result)
//     // Assign the fetched data to the nodes
//     nodes.value = result;
// }
</script>

<template>
    <BaseLayout>
        <!-- Create project heading -->
        <Title class="mb-6">
            {{ t('views.projects.create') }}
        </Title>

        <!-- Project form -->
        <form @submit.prevent="submitProject">
            <div class="grid">
                <div class="col-12 lg:col-6">
                    <div class="grid formgrid">
                        <!-- Project name -->
                        <div class="field col-12">
                            <label for="projectName">
                                {{ t('views.projects.name') }}
                            </label>
                            <InputText id="projectName" class="w-full" v-model="form.name" />
                            <ErrorMessage :field="v$.name" />
                        </div>
                    </div>

                    <div class="grid">
                        <!-- Project description -->
                        <div class="field col">
                            <label for="projectDescription">
                                {{ t('views.projects.description') }}
                            </label>
                            <Editor id="projectDescription" class="w-full" v-model="form.description" />
                        </div>
                    </div>

                    <div class="grid">
                        <!-- Start date of the project -->
                        <div class="field col">
                            <label for="projectStartDate">{{ t('views.projects.start_date') }}</label>
                            <Calendar
                                id="projectStartDate"
                                class="w-full"
                                v-model="form.startDate"
                                dateFormat="dd-mm-yy"
                                :min-date="new Date()"
                                showIcon
                            />
                            <ErrorMessage :field="v$.startDate" />
                        </div>

                        <!-- Deadline of the project -->
                        <div class="field col">
                            <label for="projectDeadline">{{ t('views.projects.deadline') }}</label>
                            <Calendar
                                id="projectDeadline"
                                class="w-full"
                                v-model="form.deadline"
                                dateFormat="dd-mm-yy"
                                :min-date="form.startDate"
                                showTime
                                hourFormat="24"
                                showIcon
                            />
                            <ErrorMessage :field="v$.deadline" />
                        </div>
                    </div>

                    <div class="grid align-items-end">
                        <!-- Group size for the project -->
                        <div class="field col">
                            <label for="groupSize">
                                {{ t('views.projects.group_size') }}
                            </label>
                            <InputNumber id="groupSize" class="w-full" v-model="form.groupSize" :min="1" />
                            <ErrorMessage :field="v$.groupSize" />
                        </div>

                        <!-- Max score for the project -->
                        <div class="field col">
                            <label for="maxScore">{{ t('views.projects.max_score') }}</label>
                            <InputNumber id="maxScore" class="w-full" v-model="form.maxScore" :min="1" />
                            <ErrorMessage :field="v$.maxScore" />
                        </div>
                    </div>

                    <!-- Visibility of the project -->
                    <div class="grid">
                        <div class="flex align-items-center field-checkbox col-12">
                            <InputSwitch id="visibility" v-model="form.visibility" />
                            <label for="visibility">{{ t('views.projects.visibility') }}</label>
                        </div>
                    </div>

                    <!-- Score visibility of the project -->
                    <div class="grid">
                        <div class="flex align-items-center field-checkbox col-12">
                            <InputSwitch id="scoreVisibility" v-model="form.scoreVisibility" />
                            <label for="scoreVisibility">{{ t('views.projects.score_visibility') }}</label>
                        </div>
                    </div>

                    <!-- Submit button -->
                    <Button
                        :label="t('views.projects.create')"
                        type="submit"
                        icon="pi pi-check"
                        iconPos="right"
                        rounded
                    />
                </div>

                <div class="col-12 lg:col-6">
                    <!-- Upload field for docker script -->
                    <div class="field col">
                        <label for="dockerScript">
                            {{ t('views.projects.docker_upload') }}
                        </label>
                        <FileUpload
                            input="dockerScript"
                            mode="basic"
                            accept=".sh"
                            :multiple="false"
                            title="hellaur"
                            @select="onDockerScriptUpload"
                        />
                    </div>

                    <!-- Upload field for a zip file that contains the submission structure -->
                    <div class="field col">
                        <label for="submissionStructure">
                            {{ t('views.projects.submission_structure') }}
                        </label>
                        <FileUpload
                            id="submissionStructure"
                            mode="basic"
                            accept=".zip"
                            :multiple="false"
                            @select="onZipStructureUpload"
                        />
                    </div>

                    <!-- tree view for structure checks -->
                    <div>
                        <Tree :value="nodes" class="w-full md:w-30rem" @node-select="onNodeSelect" selectionMode="single">
                            <template #default="node">
                                <b :style="getNodeStyle(node.node)">{{ node.node.label }}</b>
                            </template>
                        </Tree>
                        <Button
                            label="Load Structure Checks"
                            type="button"
                            icon="pi pi-refresh"
                            iconPos="right"
                            @click="loadStructureChecks"
                            rounded
                        />

                        <InputText v-model="editedNodeName" placeholder="Edit Node Name" />

                        <Button
                            label="Edit node"
                            type="button"
                            icon="pi pi-refresh"
                            iconPos="right"
                            @click="editSelectedNode"
                            rounded
                        />

                        <Button
                            label="add node"
                            type="button"
                            icon="pi pi-refresh"
                            iconPos="right"
                            @click="addSelectedNode"
                            rounded
                        />

                        <Dropdown v-model="editedNodeType" :options="nodeTypes" />

                        <!-- <Button
                            label="Add Structure Checks"
                            type="button"
                            icon="pi pi-refresh"
                            iconPos="right"
                            @click="addNode('stop','jpg', true)"
                            rounded
                        /> -->
                    </div>
                </div>
            </div>
        </form>
    </BaseLayout>
</template>

<style scoped></style>
@/types/Project
